# -*- coding: utf-8 -*-
"""model1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11jRq59Jnc40R13gXSaJr2hTAWafwYPGy
"""

from transformers import AutoImageProcessor, AutoModelForObjectDetection  # Импорт процессора и модели для YOLOS
import torch
import torchvision.ops as ops  # Для NMS (отсечения лишних рамок)
from PIL import Image  # Работа с изображениями
import requests  # Для загрузки изображений с URL
import matplotlib.pyplot as plt  # Для отображения изображения
import matplotlib.patches as patches  # Для добавления рамок на изображение

# Функция загрузки изображения с обработкой ошибок
def load_image(url, filename="temp.jpg"):
    try:
        response = requests.get(url, stream=True)  # Загружаем изображение
        response.raise_for_status()  # Проверяем наличие ошибок
        with open(filename, "wb") as f:
            f.write(response.content)  # Сохраняем файл
        return Image.open(filename)  # Открываем изображение
    except requests.exceptions.RequestException as e:
        print(f"Ошибка загрузки изображения: {e}")
        return None

# URL изображения
image_url = "https://t3.ftcdn.net/jpg/00/92/82/86/360_F_92828652_wqMnwPmnfJHAKHYUPjwHWMpjwEZHKY86.jpg"
image = load_image(image_url)  # Загружаем изображение

# Загружаем предобученную модель YOLOS-Tiny
processor = AutoImageProcessor.from_pretrained("hustvl/yolos-tiny")  # Процессор для обработки изображения
model = AutoModelForObjectDetection.from_pretrained("hustvl/yolos-tiny")  # Модель для детекции объектов

if image:
    # Предобрабатываем изображение и передаем в модель для получения предсказаний
    inputs = processor(images=image, return_tensors="pt")  # Обработка изображения и его преобразование в тензоры (для модели YOLOS)
    outputs = model(**inputs)  # Получаем предсказания от модели

    # Извлекаем данные о предсказанных объектах
    logits = outputs.logits[0]  # Оценки классов объектов (для каждого объекта)
    bboxes = outputs.pred_boxes[0]  # Координаты ограничивающих рамок

    # Получаем размер изображения
    image_width, image_height = image.size

    # Переводим нормализованные координаты (0–1) в пиксели для дальнейшей обработки
    boxes_scaled = []
    scores = []
    labels = []

# Обрабатываем каждый предсказанный объект
    for logit, box in zip(logits, bboxes):
        score = logit.softmax(-1).max().item()  # Определяем вероятность самого вероятного класса
        label_id = logit.argmax().item()  # Получаем ID класса объекта

        # Проверяем, есть ли класс в словаре меток
        label = model.config.id2label.get(label_id, f"Unknown ({label_id})")  # Преобразуем ID в название класса

        # Фильтруем объекты с низким уровнем уверенности
        if score > 0.5 and label != "Unknown (91)":  # Исключаем неизвестные объекты и повышаем порог уверенности
            # Переводим YOLOS-координаты (cx, cy, w, h) в (x1, y1, x2, y2) для рисования рамок
            cx, cy, w, h = box.tolist()
            x1 = (cx - w / 2) * image_width
            y1 = (cy - h / 2) * image_height
            x2 = (cx + w / 2) * image_width
            y2 = (cy + h / 2) * image_height

            boxes_scaled.append([x1, y1, x2, y2])
            scores.append(score)
            labels.append(label)

    # Преобразуем данные в тензоры (многомерные массивы) для дальнейшей обработки
    if boxes_scaled:
        boxes_tensor = torch.tensor(boxes_scaled)
        scores_tensor = torch.tensor(scores)

        # Применяем Non-Maximum Suppression (NMS), чтобы удалить избыточные боксы
        keep_indices = ops.nms(boxes_tensor, scores_tensor, iou_threshold=0.5)

        # Отображаем изображение
        fig, ax = plt.subplots(1, figsize=(10, 6))
        ax.imshow(image)

        found_objects = set()  # Множество для хранения найденных объектов (без дубликатов)

        for idx in keep_indices:  # Перебираем индексы оставшихся боксов после NMS
            x1, y1, x2, y2 = boxes_tensor[idx]  # Координаты рамки объекта
            label = labels[idx]  # Название объекта
            score = scores[idx]  # Уверенность в предсказании

            # Рисуем рамку вокруг объекта
            rect = patches.Rectangle((x1, y1), x2 - x1, y2 - y1, linewidth=2, edgecolor='red', facecolor='none')
            ax.add_patch(rect)

            # Добавляем подпись с названием объекта и уверенностью
            ax.text(x1, y1 - 5, f"{label}: {score:.2f}", color='red', fontsize=12, weight='bold')

            found_objects.add(label)  # Добавляем объект в множество найденных

        # Выводим список найденных объектов в консоль
        print("Обнаруженные объекты:")
        for obj in found_objects:  # Выводим каждое уникальное название объекта
            print(f"- {obj}")

        plt.show()  # Показываем изображение с рамками

    else:
        print("Нет обнаруженных объектов с высокой уверенностью.")